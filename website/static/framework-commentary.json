{
  "generated_at": "2025-08-19T19:02:39Z",
  "items": [
    {
      "id": "vanilla",
      "name": "Vanilla JS",
      "commentary": "## Vanilla JavaScript Implementation\n\nThis implementation uses pure JavaScript without any frameworks or build tools, representing the baseline web platform approach."
    },
    {
      "id": "react",
      "name": "React",
      "commentary": "## React Implementation\n\nReact is everywhere, powering millions of websites and used by every major tech company. It's been around for over 12 years, and both React and its tooling are incredibly mature. There's a reason it became the default choice for so many teams - the ecosystem is massive, jobs are plentiful, and you can build basically anything.\n\nBut it's not perfect. Our weather app showcases both React's strengths and frustrations. The component model is elegant, `useState` and `useEffect` work fine for simple state, and the custom `useWeatherData` hook abstracts the weather logic nicely. But you're constantly thinking about re-renders, dependency arrays, and manual memoization.\n\nThe virtual DOM adds overhead that other frameworks avoid entirely. Need to optimize performance? Time to sprinkle `React.memo`, `useCallback`, and `useMemo` everywhere. Coming from Svelte or Solid, all this manual work feels tedious. But the developer tooling is exceptional and the community support is unmatched.\n\n### Notable files\n- `src/App.jsx` - Main component with hooks-based state management\n- `src/hooks/useWeatherData.js` - Custom hook for weather logic and API calls\n- `src/components/ErrorBoundary.jsx` - Error boundary for crash protection\n- `src/components/` - Modular functional components\n\nThe JSX syntax is familiar once you get used to the quirks - `className` instead of `class`, self-closing tags, and JavaScript expressions in curly braces. Controlled components with `value` and `onChange` work well for forms, though they're more verbose than Vue's `v-model`.\n\nReact really shines for complex applications where the ecosystem matters. We didn't need Redux, React Query, or code splitting for this simple weather app, but for something like [Web Check](https://github.com/lissy93/web-check), these tools become essential. The flexibility to choose your own architecture is both React's blessing and curse."
    },
    {
      "id": "angular",
      "name": "Angular",
      "commentary": "Angular isn't the cool kid anymore, but it's incredibly solid and ships with absolutely everything you need. TypeScript from day one, dependency injection, forms, HTTP client, routing, testing utilities - it's all there, officially maintained and deeply integrated. No need to cobble together a stack from random npm packages.\n\nFor our weather app, Angular did kinda feel like using a sledgehammer to crack a nut. Using the newer standalone components (no more `NgModule` boilerplate!) made things cleaner, but I was still writing a lot more code than I needed in Svelte or Vue. That said, everything does just works, and the TypeScript integration is phenomenal.\n\nThe dependency injection system was quite nice for having `WeatherService` automatically injected into components. And RxJS observables handle all the async weather data very nicley, though they do add a learning curve if you're not familiar with reactive programming.\n\n### Notable files\n- `src/app/app.component.ts` - Root component with weather state management\n- `src/app/services/weather.service.ts` - Injectable service using Angular's HttpClient\n- `src/app/services/weather-state.service.ts` - Centralized state with RxJS observables\n- `src/app/components/` - Standalone components for weather display\n- `src/app/types/weather.types.ts` - TypeScript interfaces for type safety\n\nAngular's template syntax with `*ngIf`, `*ngFor`, and `(click)` feels natural once you get used to it. Change detection just works without thinking about it (unlike React where you're constantly memoizing things).\n\nFor a simple weather app, we really didn't need any of Angular's big or flagship features (like guards, resolvers, or lazy loading). But I recently build [Domain Locker](https://github.com/lissy93/domain-locker) using Angular, and it was a great fit for the complexity of that project, As the structure, type safety, and tooling made it easy to manage a large codebase with multiple features."
    },
    {
      "id": "svelte",
      "name": "Svelte",
      "commentary": "## Svelte Implementation\n\nSvelte is just *fun*. There's something magical about writing `count += 1` and having the UI automatically update. No `useState`, no `useEffect`, no `ref()` - just assign to a variable and it reacts. This is how UI frameworks should work.\n\nUnlike React or Vue, Svelte doesn't ship a runtime. Your components get compiled into highly optimized vanilla JavaScript at build time. The result? Tiny bundles, blazing fast performance, and surprisingly readable compiled output. Our weather app compiles down to around 15KB, which is frankly ridiculous for a full-featured application.\n\nThe `$:` reactive statements are brilliant for computed values - `$: tempDisplay = `${temp}Â°C`` just works and updates whenever `temp` changes. Svelte stores handle global state beautifully, and the automatic subscription cleanup means you never have to worry about memory leaks.\n\n### Notable files\n- `src/routes/+page.svelte` - Main page using SvelteKit's file-based routing\n- `src/lib/stores/weather-store.js` - Global state with Svelte writable stores\n- `src/lib/services/weather-service.js` - API calls integrated with stores\n- `src/lib/components/` - Single-file components with scoped styles\n\nThe template syntax feels natural - `{#if}`, `{#each}`, and `{#await}` blocks handle conditional rendering and async data elegantly. Two-way binding with `bind:value` eliminates the usual form boilerplate you'd write in React.\n\nFor our simple weather app, we didn't need Svelte's built-in animations or transitions. But Svelte is my go to choice for nearly all my personal projects, as these features become incredibly powerful. The `transition:` and `animate:` directives can make your UI feel incredibly polished with minimal code."
    },
    {
      "id": "preact",
      "name": "Preact",
      "commentary": "## Preact Implementation\n\nIf you love React but hate the bundle size, Preact is your best friend. It's essentially React, but 3KB instead of 40KB. Same hooks, same JSX, same mental model - just way more efficient. You can literally take a React component, change the import from `react` to `preact`, and it'll work.\n\nFor our weather app, switching from React to Preact required basically zero changes. The `useWeatherData` custom hook works identically, functional components behave the same, and `useState` does exactly what you'd expect. But the compiled bundle is drastically smaller and noticeably faster.\n\nPreact's secret sauce is smart optimizations under the hood. It skips unnecessary work that React's virtual DOM usually does, and includes automatic component memoization that you'd have to add manually in React with `memo()`. The reconciliation algorithm is also more direct, making updates snappier.\n\n### Notable files\n- `src/App.jsx` - Main component with familiar React-style hooks\n- `src/hooks/useWeatherData.js` - Custom hook for weather state and API calls\n- `src/components/` - Standard functional components with hooks\n- `src/services/WeatherService.js` - API service using native fetch\n\nThe developer experience is identical to React. Hot refresh works perfectly, the dev tools are solid, and you can use most React libraries via `preact/compat`. Really, the only difference is your bundle analyzer will make you smile.\n\nI didn't need Preact's router or state management libraries for this simple app, but they follow the same lightweight philosophy. For anything bigger, you'd probably reach for the React ecosystem anyway via the compat layer."
    },
    {
      "id": "solid",
      "name": "Solid.js",
      "commentary": "## Solid Implementation\n\nSolid feels like React, but *actually* reactive. It looks like JSX, but underneath it's magic. While React re-renders entire component trees, Solid surgically updates only the exact DOM nodes that need to change. The result is performance that makes other frameworks look sluggish.\n\nThe mental shift from React is subtle but profound. Instead of thinking about re-renders and memoization, you think about signals and reactivity. `createSignal` returns a getter and setter - call `temperature()` to read, `setTemperature(25)` to update, and everything that depends on it automatically updates.\n\nOur weather app showcases this, as the temperature display, the weather icon, the styling - they all react independently when the weather data changes. No `useEffect`, no dependency arrays, no `useMemo` - just pure reactive programming that actually works.\n\n### Notable files\n- `src/App.jsx` - Main component using Solid's reactive primitives\n- `src/stores/weatherStore.js` - Global state with `createStore`\n- `src/services/WeatherService.js` - API integration with `createResource`\n- `src/components/` - Reactive components that update precisely\n\nThe JSX looks familiar, but `<Show>` and `<For>` components replace your typical `{condition && <div>}` patterns. These aren't just syntactic sugar - they're compiled into efficient conditional rendering that only updates when necessary.\n\n`createResource` handles async data elegantly, giving you loading states, error handling, and refetching without the usual ceremony. For our simple weather app, we didn't need Solid's more advanced features like stores or effects, but for something complex, the fine-grained reactivity becomes essential."
    },
    {
      "id": "qwik",
      "name": "Qwik",
      "commentary": "## Qwik Implementation\n\nQwik is kinda wild. It completely rethinks how web apps work by doing something called \"resumability\" - your page loads instantly with zero JavaScript, then individual components wake up only when you interact with them. It's like having a webpage that's asleep until you poke it.\n\nThe secret is those `$` symbols everywhere. `component$()`, `useTask$()`, `onClick$()` - these aren't just weird syntax, they're lazy loading boundaries. Each `$` tells Qwik \"this code can be loaded later when needed.\" So clicking a button doesn't load the entire app, it just loads that specific button's handler.\n\nFor our weather app, this means the initial page render is lightning fast - just HTML and CSS. Search for a city, and only *then* does the search logic get loaded. Click to expand a forecast day, and only the expansion code gets fetched. It's incremental interactivity taken to its logical extreme.\n\n### Notable files\n- `src/App.tsx` - Main component with resumable state\n- `src/stores/weatherStore.ts` - Qwik stores that serialize automatically  \n- `src/services/WeatherService.ts` - API calls with progressive loading\n- `src/components/` - Components that wake up on demand\n\nThe state management feels familiar but with superpowers. Qwik stores automatically serialize to HTML, so when components resume, they pick up exactly where they left off. No hydration mismatch, no loading spinners, just seamless continuation. For that reason, I used Qwik to build the interactive stuff on my [Digital Defense](https://digital-defense.io/) website.\n\nThe trade-off is developer complexity - all those `$` symbols take getting used to, and debugging can be tricky when code loads on-demand. But for performance-critical apps, especially content-heavy sites, Qwik's approach is genuinely revolutionary. Your Core Web Vitals scores will thank you."
    },
    {
      "id": "vue",
      "name": "Vue",
      "commentary": "## Vue Implementation\n\nVue sits in the Goldilocks zone - not as minimal as Alpine, not as opinionated as Angular, just right for most projects. It feels like the framework that actually learned from React's mistakes while keeping the good parts. Single File Components are brilliant, the template syntax is intuitive, and reactivity just works without the mental gymnastics of `useEffect`.\n\nFor our weather app, Vue felt natural and productive. The `v-if`, `v-for`, and `v-model` directives handle conditional rendering, lists, and form inputs elegantly. No weird JSX quirks, no manual event handling - just HTML that does what you expect. The Composition API gives you React-style logic organization when you need it, but Options API is still there for simpler components.\n\nThe reactivity system using Proxies is genuinely impressive. Change a data property and everything dependent on it updates automatically. No `useState`, no memoization hell, no stale closures. Vue tracks dependencies behind the scenes and updates only what needs to change.\n\n### Notable files\n- `src/App.vue` - Main component using Vue's Composition API\n- `src/services/weatherService.js` - API integration with Vue's reactive patterns  \n- `src/components/` - Single File Components with scoped styles\n- `src/utils/weatherUtils.js` - Utility functions for data processing\n\nThe Single File Component format is perfect - template, script, and styles all in one file with proper scoping. `<style scoped>` means your CSS only affects that component, no global pollution or CSS-in-JS complexity. It just works the way you'd expect.\n\nVue's ecosystem is mature without being overwhelming. I didn't need Vue Router or Pinia for this simple app, but they're there when you need them.\n\nI chose Vue for [Dashy](https://github.com/Lissy93/dashy/), because it both has everything I needed, but also is incredbily easy, so contributors could add their own widgets and features, with out a steep learning curve."
    },
    {
      "id": "jquery",
      "name": "jQuery",
      "commentary": "Let's be honest - building a modern app with jQuery in 2024 feels like showing up to a Formula 1 race with a vintage car. It'll get you there, but everyone will wonder what the f*ck you are on. Still, jQuery powered the web for over a decade, and is still actually very widley used (thanks WordPress), so it's worth understanding what made it so dominant. Nowadays pertty much everything jQuery could do, is implemented into ES6+ natively, so there's little point in jQuery (unless u r supporting IE11).\n\nThe TL;DR of jQuery's magic was always in the simplicity. `$('#weather-display').html(weatherHtml)` just *works*. No virtual DOM, no component lifecycle, no build process - just select elements and manipulate them. The method chaining is genuinely elegant: `$('.forecast-item').addClass('active').fadeIn(300)` reads like English.\n\nFor our weather app, jQuery actually handles the basic functionality fine. Event delegation with `$(document).on('click', '.forecast-toggle', handler)` works perfectly, and `$.ajax()` fetches weather data without fuss. But you quickly realize you're manually managing everything React or Vue handles automatically - state updates, DOM synchronization, component organization.\n\n### Notable files\n- `src/main.js` - Application initialization and jQuery setup\n- `src/components/weather-ui.js` - Manual DOM management and event handling\n- `src/services/weather-service.js` - API calls with `$.ajax()`\n- `index.html` - Plain HTML structure with jQuery CDN\n\nThe imperative style becomes tedious fast. Want to update the temperature display? Manually find the element and change its text. Need to show/hide loading states? Manually toggle CSS classes. It works, but you'll write 3x more code than you would in Svelte.\n\njQuery still has its place for simple enhancements to static sites, but for anything interactive, modern frameworks or even vanilla JS, are just better. The ecosystem and community have largely moved on, and you'll spend more time fighting against jQuery's limitations than building features."
    },
    {
      "id": "alpine",
      "name": "Alpine.js",
      "commentary": "Alpine.js is like jQuery had a baby with Vue and decided to live directly in your HTML. It's refreshingly simple - you sprinkle a few `x-` attributes into your markup and suddenly you have reactive behavior. No build tools, no bundlers, no complexity. Just add a script tag and start building.\n\nThe approach feels intuitive once you get it. `x-data` sets up your reactive state, `x-show` handles conditional rendering, and `x-for` loops through arrays. Our weather app's forecast list is just `<div x-for=\"day in forecast\">` - no components, no imports, no ceremony.\n\nWhat's clever is how Alpine stays out of your way. The HTML is still readable, the JavaScript is minimal, and everything degrades gracefully if Alpine doesn't load. It's progressive enhancement done right - the page works without JavaScript, but becomes interactive when it loads.\n\n### Notable files\n- `index.html` - Main HTML with Alpine directives sprinkled in\n- `js/weather-app.js` - Alpine data and methods for weather logic\n- `js/weather-service.js` - API calls integrated with Alpine reactivity\n- `js/weather-utils.js` - Utility functions for data formatting\n\nThe syntax reads naturally: `x-on:click=\"searchWeather()\"`, `x-text=\"temperature\"`, `x-bind:class=\"{'active': isExpanded}\"`. It's declarative like Vue templates but lives right in the HTML. The reactive updates happen automatically when you modify the data.\n\nFor simple interactive websites, Alpine hits the sweet spot. You get modern reactivity without the complexity of a full framework. But for anything complex, you'll miss proper component organization and tooling. Alpine works great for [my whois lookup API](https://github.com/Lissy93/who-dat), because I just needed sprinkles of interactivity to update results, not a full SPA experience."
    },
    {
      "id": "lit",
      "name": "Lit",
      "commentary": "## Lit Implementation\n\nLit feels like stepping back into the old React class component days, but with web standards. It's built around Web Components, which is both its greatest strength and biggest frustration. Everything is properly encapsulated and framework-agnostic, but the developer experience feels surprisingly verbose for 2024.\n\nThe weird expression syntax caught me constantly. Want to bind a property? Use `.value=\"${this.temp}\"`. A boolean attribute? `?disabled=\"${this.loading}\"`. An event listener? `@click=\"${this.handleClick}\"`. It's functional once you memorize the symbols, but it breaks the flow when you're trying to think about business logic.\n\nClass-based components feel outdated after years of hooks and functional patterns. Creating a simple weather display requires extending `LitElement`, defining `@property` decorators, implementing `render()`, and handling lifecycle methods manually. It works, but feels like unnecessary ceremony.\n\n### Notable files\n- `src/weather-app.js` - Main application as a custom element\n- `src/weather-display.js` - Weather data display component\n- `src/weather-forecast.js` - Forecast list with lit-html templates\n- `src/weather-search.js` - Search form component with event binding\n\nThe shadow DOM isolation is cool in theory - your styles can't leak, global CSS can't interfere. But in practice, it creates more problems than it solves. Want to style components consistently? Good luck getting your design system to work across shadow boundaries. Because of this, I really struggled to get the shared weather styles working across the Lit app. If you want to submit a PR to fix this, please do!\n\nBut Lit really does shine for design systems and component libraries where you need true framework-agnostic components. I did build [Email Comparison](https://email-comparison.as93.net/) in Lit, but in heindsite, I think that was a mistake!"
    },
    {
      "id": "vanjs",
      "name": "VanJS",
      "commentary": "## VanJS Implementation\n\nVanJS is impressively tiny - just 1KB of runtime with zero dependencies. It's basically \"what if we took the reactive parts of modern frameworks and stripped away everything else?\" The result is surprisingly elegant for simple applications, but you'll quickly bump into its limitations.\n\nThe functional approach is refreshing after dealing with classes and complex component lifecycles. `van.state(initialValue)` creates reactive state, `van.tags.div()` creates DOM elements, and everything just works. Our weather app's temperature display is literally `van.tags.span(temperature)` - when `temperature` changes, the DOM updates automatically.\n\nBut the simplicity comes with trade-offs. There's no component abstraction beyond functions, no templating system, no event system. You're essentially building a reactive version of vanilla DOM manipulation. It works for basic interactivity but gets unwieldy fast.\n\n### Notable files\n- `src/main.js` - Application logic with VanJS state and DOM creation\n- `src/weather-service.js` - API calls that update VanJS reactive state\n- `src/weather-utils.js` - Utility functions for data processing\n- `index.html` - Minimal HTML with VanJS script tag\n\nThe DOM creation syntax is functional but verbose: `van.tags.div({class: \"weather-card\"}, van.tags.h2(\"Weather\"))`. Coming from JSX or template languages, it feels like writing assembly code. You'll miss the declarative nature of modern frameworks.\n\nVanJS works well for simple enhancements where you need just a touch of reactivity without the framework overhead. I've used it for mini apps, like [raid-calculator](https://github.com/lissy93/raid-calculator). But for anything substantial, you'll spend more time fighting the limitations than building features. It's an interesting experiment in minimalism, but modern frameworks exist for good reasons."
    }
  ]
}