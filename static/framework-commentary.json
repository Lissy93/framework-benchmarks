{
  "generated_at": "2025-10-30T05:05:58Z",
  "items": [
    {
      "id": "react",
      "name": "React",
      "implementation": "#### Custom Hooks\nThe [`useWeatherData`](https://github.com/Lissy93/framework-benchmarks/blob/main/apps/react/src/hooks/useWeatherData.js) custom hook encapsulates all weather-related state and logic, demonstrating React's hooks pattern for reusable stateful logic.\n\n#### Error Boundary\nThe app includes an [`ErrorBoundary`](https://github.com/Lissy93/framework-benchmarks/blob/main/apps/react/src/components/ErrorBoundary.jsx) component using class-based lifecycle methods to catch JavaScript errors anywhere in the component tree.\n\n#### useCallback & useEffect Optimization\nExtensive use of `useCallback` for memoizing functions and `useEffect` with proper dependency arrays to prevent unnecessary re-renders and infinite loops.\n\n#### Conditional Rendering Patterns\nReact's conditional rendering using logical operators (`&&`) and ternary expressions for showing loading states, errors, and weather content based on application state.\n\n#### Functional Components\nAll components are functional components using hooks, showcasing modern React patterns over legacy class-based components.",
      "about": "React is the most popular frontend library, created by Facebook in 2013. \nIt popularised the component model and virtual DOM, changing frontend forever. \nIts ecosystem is massive, with libraries for everything. \nThe downside is that it’s just a view layer, so you end up wiring lots of pieces together. \nStill, it runs huge apps like Facebook, Instagram and Netflix.",
      "thoughts": "React is everywhere, powering millions of websites and used by every major tech company. It's been around for over 12 years, and both React and its tooling are incredibly mature. There's a reason it became the default choice for so many teams - the ecosystem is massive, jobs are plentiful, and you can build basically anything.\n\nBut it's not perfect. Our weather app showcases both React's strengths and frustrations. The component model is elegant, `useState` and `useEffect` work fine for simple state, and the custom `useWeatherData` hook abstracts the weather logic nicely. But you're constantly thinking about re-renders, dependency arrays, and manual memoization.\n\nThe virtual DOM adds overhead that other frameworks avoid entirely. Need to optimize performance? Time to sprinkle `React.memo`, `useCallback`, and `useMemo` everywhere. Coming from Svelte or Solid, all this manual work feels tedious. But the developer tooling is exceptional and the community support is unmatched.\n\nThe JSX syntax is familiar once you get used to the quirks - `className` instead of `class`, self-closing tags, and JavaScript expressions in curly braces. Controlled components with `value` and `onChange` work well for forms, though they're more verbose than Vue's `v-model`.\n\nReact really shines for complex applications where the ecosystem matters. We didn't need Redux, React Query, or code splitting for this simple weather app, but for something like [Web Check](https://github.com/lissy93/web-check), these tools become essential. The flexibility to choose your own architecture is both React's blessing and curse."
    },
    {
      "id": "angular",
      "name": "Angular",
      "implementation": "#### Dependency Injection & Services\nThe app uses Angular's dependency injection system with services marked as `@Injectable({ providedIn: 'root' })`. The [`WeatherStateService`](https://github.com/Lissy93/framework-benchmarks/blob/main/apps/angular/src/app/services/weather-state.service.ts) manages global state using RxJS `BehaviorSubject`.\n\n#### RxJS Reactive Patterns\nState management leverages RxJS observables with operators like `catchError`, `finalize`, `switchMap`, and `delay`. The app component uses `takeUntil` pattern for subscription cleanup to prevent memory leaks.\n\n#### Standalone Components\nAll components use Angular's modern standalone API, eliminating the need for NgModules. Components import their dependencies directly in the `imports` array.\n\n#### Inline Templates\nThe [`AppComponent`](https://github.com/Lissy93/framework-benchmarks/blob/main/apps/angular/src/app/app.component.ts) demonstrates Angular's inline template syntax with data binding (`[isLoading]`, `(search)`), structural directives, and conditional rendering.\n\n#### TypeScript Integration\nFull TypeScript support with typed interfaces for weather data and app state, providing compile-time type checking and better developer experience.",
      "about": "Angular is a full-blown framework from Google, not just a library. \nIt comes with everything out of the box, from routing to forms to testing. \nIts TypeScript-first approach and structured architecture make it great for large, enterprise apps. \nThe learning curve is steep but it’s incredibly powerful when mastered.",
      "thoughts": "Angular isn't the cool kid anymore, but it's incredibly solid and ships with absolutely everything you need. TypeScript from day one, dependency injection, forms, HTTP client, routing, testing utilities - it's all there, officially maintained and deeply integrated. No need to cobble together a stack from random npm packages.\n\nFor our weather app, Angular did kinda feel like using a sledgehammer to crack a nut. Using the newer standalone components (no more `NgModule` boilerplate!) made things cleaner, but I was still writing a lot more code than I needed in Svelte or Vue. That said, everything does just works, and the TypeScript integration is phenomenal.\n\nThe dependency injection system was quite nice for having `WeatherService` automatically injected into components. And RxJS observables handle all the async weather data very nicley, though they do add a learning curve if you're not familiar with reactive programming.\n\nAngular's template syntax with `*ngIf`, `*ngFor`, and `(click)` feels natural once you get used to it. Change detection just works without thinking about it (unlike React where you're constantly memoizing things).\n\nFor a simple weather app, we really didn't need any of Angular's big or flagship features (like guards, resolvers, or lazy loading). But I recently build [Domain Locker](https://github.com/lissy93/domain-locker) using Angular, and it was a great fit for the complexity of that project, As the structure, type safety, and tooling made it easy to manage a large codebase with multiple features."
    },
    {
      "id": "svelte",
      "name": "Svelte",
      "implementation": "#### Svelte Stores\nThe [`weather-store.js`](https://github.com/Lissy93/framework-benchmarks/blob/main/apps/svelte/src/lib/stores/weather-store.js) uses Svelte's writable stores for global state management. Store actions are grouped in an object, providing a clean API for weather operations.\n\n#### Reactivity Without Framework Runtime\nSvelte compiles away at build time, meaning no virtual DOM or framework code ships to the browser. Reactive statements using `$:` syntax automatically recompute when dependencies change.\n\n#### Built-in State Management\nNo external state management library needed - Svelte's stores handle global state with automatic reactivity. Components can subscribe to stores using the `$store` syntax.\n\n#### SvelteKit Integration\nUses SvelteKit's file-based routing with `+page.svelte` and `+layout.svelte`. The `$app/environment` module provides SSR-safe environment detection with the `browser` check.\n\n#### Simplified Component Syntax\nSvelte components use `<script>`, `<template>`, and `<style>` sections, but with less boilerplate than other frameworks - no need for explicit return statements or render functions.",
      "about": "Svelte compiles your code at build time into minimal JS with no runtime framework. \nThat makes it very fast, with tiny bundle sizes. \nIt’s one of the most loved frameworks in surveys like Stack Overflow’s. \nThe syntax is simple and elegant, and it feels closer to writing plain HTML, CSS and JS. \nThe main drawback is a smaller ecosystem compared to React or Vue.",
      "thoughts": "Svelte is just *fun*. There's something magical about writing `count += 1` and having the UI automatically update. No `useState`, no `useEffect`, no `ref()` - just assign to a variable and it reacts. This is how UI frameworks should work.\n\nUnlike React or Vue, Svelte doesn't ship a runtime. Your components get compiled into highly optimized vanilla JavaScript at build time. The result? Tiny bundles, blazing fast performance, and surprisingly readable compiled output. Our weather app compiles down to around 15KB, which is frankly ridiculous for a full-featured application.\n\nThe `$:` reactive statements are brilliant for computed values - `$: tempDisplay = `${temp}°C`` just works and updates whenever `temp` changes. Svelte stores handle global state beautifully, and the automatic subscription cleanup means you never have to worry about memory leaks.\n\nThe template syntax feels natural - `{#if}`, `{#each}`, and `{#await}` blocks handle conditional rendering and async data elegantly. Two-way binding with `bind:value` eliminates the usual form boilerplate you'd write in React.\n\nFor our simple weather app, we didn't need Svelte's built-in animations or transitions. But Svelte is my go to choice for nearly all my personal projects, as these features become incredibly powerful. The `transition:` and `animate:` directives can make your UI feel incredibly polished with minimal code."
    },
    {
      "id": "preact",
      "name": "Preact",
      "implementation": "#### React API Compatibility\nPreact provides a nearly identical API to React, using the same hooks (`useState`, `useEffect`, `useCallback`) and patterns but in a much smaller bundle (~3KB vs React's ~42KB).\n\n#### Race Condition Handling\nThe [`useWeatherData`](https://github.com/Lissy93/framework-benchmarks/blob/main/apps/preact/src/hooks/useWeatherData.js) hook implements sophisticated race condition prevention using `useRef` to track the latest request ID, ensuring stale requests don't override newer ones.\n\n#### Import from preact/hooks\nUses `import { useState, useEffect } from 'preact/hooks'` instead of React's import paths, but otherwise the code is virtually identical to React patterns.\n\n#### Smaller Bundle Size\nPreact's lightweight nature means the entire weather app compiles to a significantly smaller bundle while maintaining full React compatibility for most use cases.\n\n#### Fast Refresh Support\nModern Preact setup with Vite provides the same fast refresh development experience as React, with instant hot reloading during development.",
      "about": "Preact is a tiny React alternative that’s API-compatible with React in most cases. \nIt’s known for its speed and small bundle size, making it perfect for performance-sensitive projects. \nBig names like Uber and Lyft have used it in production. \nThe trade-off is that some advanced React features are missing or behave differently.",
      "thoughts": "If you love React but hate the bundle size, Preact is your best friend. It's essentially React, but 3KB instead of 40KB. Same hooks, same JSX, same mental model - just way more efficient. You can literally take a React component, change the import from `react` to `preact`, and it'll work.\n\nFor our weather app, switching from React to Preact required basically zero changes. The `useWeatherData` custom hook works identically, functional components behave the same, and `useState` does exactly what you'd expect. But the compiled bundle is drastically smaller and noticeably faster.\n\nPreact's secret sauce is smart optimizations under the hood. It skips unnecessary work that React's virtual DOM usually does, and includes automatic component memoization that you'd have to add manually in React with `memo()`. The reconciliation algorithm is also more direct, making updates snappier.\n\nThe developer experience is identical to React. Hot refresh works perfectly, the dev tools are solid, and you can use most React libraries via `preact/compat`. Really, the only difference is your bundle analyzer will make you smile.\n\nI didn't need Preact's router or state management libraries for this simple app, but they follow the same lightweight philosophy. For anything bigger, you'd probably reach for the React ecosystem anyway via the compat layer."
    },
    {
      "id": "solid",
      "name": "Solid.js",
      "implementation": "#### Fine-Grained Reactivity with Signals\nThe [`weatherStore.js`](https://github.com/Lissy93/framework-benchmarks/blob/main/apps/solid/src/stores/weatherStore.js) uses SolidJS's `createSignal()` for fine-grained reactivity. Unlike React, changes only update specific DOM nodes, not entire component trees.\n\n#### JSX Without Virtual DOM\nSolidJS uses JSX syntax but compiles to real DOM operations. No virtual DOM overhead - changes are tracked at the signal level and update the DOM directly.\n\n#### Signal Accessors\nSignals return getter/setter pairs: `const [count, setCount] = createSignal(0)`. The store exposes both getter functions and signal accessors for flexible consumption patterns.\n\n#### Race Condition Prevention\nThe store implements request ID tracking (`latestRequestId`) to prevent race conditions when multiple async operations are in flight simultaneously.\n\n#### Reactive Dependencies\nSolidJS automatically tracks dependencies, so reactive computations only re-run when their actual dependencies change, not when the entire component re-renders.",
      "about": "Solid looks like React on the surface but skips the virtual DOM, updating the DOM directly with fine-grained reactivity. \nThis makes it blazing fast and efficient. \nIt has a smaller community but a lot of buzz among developers chasing performance. \nIf you like React’s syntax but hate its runtime overhead, Solid is refreshing.",
      "thoughts": "Solid feels like React, but *actually* reactive. It looks like JSX, but underneath it's magic. While React re-renders entire component trees, Solid surgically updates only the exact DOM nodes that need to change. The result is performance that makes other frameworks look sluggish.\n\nThe mental shift from React is subtle but profound. Instead of thinking about re-renders and memoization, you think about signals and reactivity. `createSignal` returns a getter and setter - call `temperature()` to read, `setTemperature(25)` to update, and everything that depends on it automatically updates.\n\nOur weather app showcases this, as the temperature display, the weather icon, the styling - they all react independently when the weather data changes. No `useEffect`, no dependency arrays, no `useMemo` - just pure reactive programming that actually works.\n\nThe JSX looks familiar, but `<Show>` and `<For>` components replace your typical `{condition && <div>}` patterns. These aren't just syntactic sugar - they're compiled into efficient conditional rendering that only updates when necessary.\n\n`createResource` handles async data elegantly, giving you loading states, error handling, and refetching without the usual ceremony. For our simple weather app, we didn't need Solid's more advanced features like stores or effects, but for something complex, the fine-grained reactivity becomes essential."
    },
    {
      "id": "qwik",
      "name": "Qwik",
      "implementation": "#### Resumability & Serialization\nQwik's defining feature is resumability - the app can be paused on the server and resumed on the client without re-execution. Functions prefixed with `$` like `$(async (city: string) => {...})` create serialization boundaries.\n\n#### useSignal for State\nThe [`App.tsx`](https://github.com/Lissy93/framework-benchmarks/blob/main/apps/qwik/src/App.tsx) uses `useSignal<WeatherData | null>(null)` for reactive state management, similar to React but optimized for Qwik's lazy execution model.\n\n#### Context API\nThe [`weatherStore.ts`](https://github.com/Lissy93/framework-benchmarks/blob/main/apps/qwik/src/stores/weatherStore.ts) defines a context using `createContextId<WeatherState>('weather')` for sharing state across components without prop drilling.\n\n#### useVisibleTask$ Optimization\nQwik's `useVisibleTask$()` only runs when the component becomes visible, enabling fine-grained lazy loading and reducing initial JavaScript execution.\n\n#### File-based Routing\nUses Qwik City's file-based routing system with `routes/index.tsx` automatically mapping to the root path, similar to Next.js but with Qwik's resumability benefits.",
      "about": "Qwik is all about instant load times and fine-grained lazy loading. \nIt serialises app state into HTML, letting pages become interactive with almost zero JS upfront. \nIt’s built for the modern web where performance and SEO matter. \nIt feels experimental but it’s pushing interesting ideas around resumability.",
      "thoughts": "Qwik is kinda wild. It completely rethinks how web apps work by doing something called \"resumability\" - your page loads instantly with zero JavaScript, then individual components wake up only when you interact with them. It's like having a webpage that's asleep until you poke it.\n\nThe secret is those `$` symbols everywhere. `component$()`, `useTask$()`, `onClick$()` - these aren't just weird syntax, they're lazy loading boundaries. Each `$` tells Qwik \"this code can be loaded later when needed.\" So clicking a button doesn't load the entire app, it just loads that specific button's handler.\n\nFor our weather app, this means the initial page render is lightning fast - just HTML and CSS. Search for a city, and only *then* does the search logic get loaded. Click to expand a forecast day, and only the expansion code gets fetched. It's incremental interactivity taken to its logical extreme.\n\nThe state management feels familiar but with superpowers. Qwik stores automatically serialize to HTML, so when components resume, they pick up exactly where they left off. No hydration mismatch, no loading spinners, just seamless continuation. For that reason, I used Qwik to build the interactive stuff on my [Digital Defense](https://digital-defense.io/) website.\n\nThe trade-off is developer complexity - all those `$` symbols take getting used to, and debugging can be tricky when code loads on-demand. But for performance-critical apps, especially content-heavy sites, Qwik's approach is genuinely revolutionary. Your Core Web Vitals scores will thank you."
    },
    {
      "id": "vue",
      "name": "Vue",
      "implementation": "#### Composition API\nThe [`App.vue`](https://github.com/Lissy93/framework-benchmarks/blob/main/apps/vue/src/App.vue) uses Vue 3's Composition API with `<script setup>` syntax, providing a more flexible and reusable way to organize component logic compared to the Options API.\n\n#### Single File Components\nAll components use Vue's SFC format, combining template, script, and style in a single `.vue` file with clear separation of concerns.\n\n#### Reactive References\nUses Vue's `ref()` for reactive state management, with automatic reactivity tracking that eliminates the need for manual dependency management.\n\n#### Template Directives\nLeverages Vue's powerful template directives like `v-if`, `v-for`, and event binding with `@` syntax for declarative and readable templates.\n\n#### Lifecycle Hooks\nThe `onMounted` hook demonstrates Vue's composition API lifecycle management, providing a clean way to handle component initialization.",
      "about": "Vue was created by Evan You after working on Angular at Google, and it became hugely popular thanks to its simplicity. \nIt mixes the best ideas of Angular and React but with a gentler learning curve. \nIts ecosystem includes Vue Router and Vuex, and it’s used by Alibaba, Xiaomi and GitLab. \nDevelopers love its approachability and elegance.",
      "thoughts": "Vue sits in the Goldilocks zone - not as minimal as Alpine, not as opinionated as Angular, just right for most projects. It feels like the framework that actually learned from React's mistakes while keeping the good parts. Single File Components are brilliant, the template syntax is intuitive, and reactivity just works without the mental gymnastics of `useEffect`.\n\nFor our weather app, Vue felt natural and productive. The `v-if`, `v-for`, and `v-model` directives handle conditional rendering, lists, and form inputs elegantly. No weird JSX quirks, no manual event handling - just HTML that does what you expect. The Composition API gives you React-style logic organization when you need it, but Options API is still there for simpler components.\n\nThe reactivity system using Proxies is genuinely impressive. Change a data property and everything dependent on it updates automatically. No `useState`, no memoization hell, no stale closures. Vue tracks dependencies behind the scenes and updates only what needs to change.\n\nThe Single File Component format is perfect - template, script, and styles all in one file with proper scoping. `<style scoped>` means your CSS only affects that component, no global pollution or CSS-in-JS complexity. It just works the way you'd expect.\n\nVue's ecosystem is mature without being overwhelming. I didn't need Vue Router or Pinia for this simple app, but they're there when you need them.\n\nI chose Vue for [Dashy](https://github.com/Lissy93/dashy/), because it both has everything I needed, but also is incredbily easy, so contributors could add their own widgets and features, with out a steep learning curve."
    },
    {
      "id": "jquery",
      "name": "jQuery",
      "implementation": "#### DOM-First Approach\njQuery follows a DOM-centric approach where you select elements first (`$('#weather-container')`) then manipulate them. The [`weather-ui.js`](https://github.com/Lissy93/framework-benchmarks/blob/main/apps/jquery/src/components/weather-ui.js) demonstrates classic jQuery patterns.\n\n#### Imperative DOM Manipulation\nUnlike declarative frameworks, jQuery requires explicit DOM updates. When weather data changes, you manually call `$('#temperature').text(temp)` to update the display.\n\n#### CSS Selector Power\njQuery's strength lies in its CSS selector engine. Complex DOM queries like `$('.forecast-item.active .details')` make it easy to find and manipulate specific elements.\n\n#### Event Delegation\nUses jQuery's event delegation with `.on()` method to handle dynamically added forecast items, ensuring click handlers work on elements added after page load.\n\n#### AJAX Integration\nThe weather service leverages jQuery's `$.ajax()` method for HTTP requests, providing a clean Promise-like interface with `.done()` and `.fail()` callbacks.",
      "about": "jQuery was once the king of the web, making DOM manipulation and AJAX simple back when browsers were inconsistent. \nMost of what it offers is now part of vanilla JS, so it’s largely unnecessary today. \nStill, it powered much of the modern web and is a big part of web history.",
      "thoughts": "Let's be honest - building a modern app with jQuery in 2024 feels like showing up to a Formula 1 race with a vintage car. It'll get you there, but everyone will wonder what the f*ck you are on. Still, jQuery powered the web for over a decade, and is still actually very widley used (thanks WordPress), so it's worth understanding what made it so dominant. Nowadays pertty much everything jQuery could do, is implemented into ES6+ natively, so there's little point in jQuery (unless u r supporting IE11).\n\nThe TL;DR of jQuery's magic was always in the simplicity. `$('#weather-display').html(weatherHtml)` just *works*. No virtual DOM, no component lifecycle, no build process - just select elements and manipulate them. The method chaining is genuinely elegant: `$('.forecast-item').addClass('active').fadeIn(300)` reads like English.\n\nFor our weather app, jQuery actually handles the basic functionality fine. Event delegation with `$(document).on('click', '.forecast-toggle', handler)` works perfectly, and `$.ajax()` fetches weather data without fuss. But you quickly realize you're manually managing everything React or Vue handles automatically - state updates, DOM synchronization, component organization.\n\nThe imperative style becomes tedious fast. Want to update the temperature display? Manually find the element and change its text. Need to show/hide loading states? Manually toggle CSS classes. It works, but you'll write 3x more code than you would in Svelte.\n\njQuery still has its place for simple enhancements to static sites, but for anything interactive, modern frameworks or even vanilla JS, are just better. The ecosystem and community have largely moved on, and you'll spend more time fighting against jQuery's limitations than building features."
    },
    {
      "id": "alpine",
      "name": "Alpine.js",
      "implementation": "#### HTML-First Approach\nAlpine.js enhances HTML directly with directives. The main `index.html` uses `x-data=\"weatherApp()\"` to bind the [`weather-app.js`](https://github.com/Lissy93/framework-benchmarks/blob/main/apps/alpine/js/weather-app.js) function to the DOM.\n\n#### Reactive Data Object\nThe `weatherApp()` function returns an object with reactive properties (`isLoading`, `hasError`, `currentWeather`) that automatically update the UI when changed.\n\n#### Alpine Directives\nUses Alpine's directive system: `x-show` for conditional visibility, `x-on:click` for event handling, and `x-text` for content binding, making it feel like Vue but with minimal JavaScript.\n\n#### No Build Step Required\nAlpine works directly in the browser without compilation. Just include the script tag and start using directives - perfect for progressively enhancing existing HTML.\n\n#### Vanilla JavaScript Integration\nThe weather logic is written in plain JavaScript functions that return reactive objects, making it easy to understand and debug without framework-specific patterns.",
      "about": "Alpine is a super lightweight framework for adding interactivity directly in HTML using attributes. \nIt feels like Tailwind but for behaviour, making it ideal for simple UI enhancements without a full build setup. \nGreat for quick prototypes or adding sprinkles of interactivity to static sites.",
      "thoughts": "Alpine.js is like jQuery had a baby with Vue and decided to live directly in your HTML. It's refreshingly simple - you sprinkle a few `x-` attributes into your markup and suddenly you have reactive behavior. No build tools, no bundlers, no complexity. Just add a script tag and start building.\n\nThe approach feels intuitive once you get it. `x-data` sets up your reactive state, `x-show` handles conditional rendering, and `x-for` loops through arrays. Our weather app's forecast list is just `<div x-for=\"day in forecast\">` - no components, no imports, no ceremony.\n\nWhat's clever is how Alpine stays out of your way. The HTML is still readable, the JavaScript is minimal, and everything degrades gracefully if Alpine doesn't load. It's progressive enhancement done right - the page works without JavaScript, but becomes interactive when it loads.\n\nThe syntax reads naturally: `x-on:click=\"searchWeather()\"`, `x-text=\"temperature\"`, `x-bind:class=\"{'active': isExpanded}\"`. It's declarative like Vue templates but lives right in the HTML. The reactive updates happen automatically when you modify the data.\n\nFor simple interactive websites, Alpine hits the sweet spot. You get modern reactivity without the complexity of a full framework. But for anything complex, you'll miss proper component organization and tooling. Alpine works great for [my whois lookup API](https://github.com/Lissy93/who-dat), because I just needed sprinkles of interactivity to update results, not a full SPA experience."
    },
    {
      "id": "lit",
      "name": "Lit",
      "implementation": "#### Web Components & Custom Elements\nThe [`weather-app.js`](https://github.com/Lissy93/framework-benchmarks/blob/main/apps/lit/src/weather-app.js) extends `LitElement` and registers as `<weather-app>` using `customElements.define()`. All components are true Web Components that work in any framework.\n\n#### Tagged Template Literals\nLit uses JavaScript tagged template literals for both HTML templates (`html\\`\\``) and CSS styles (`css\\`\\`). This provides syntax highlighting and type safety without build-time compilation.\n\n#### Reactive Properties\nStatic properties are defined with `static properties = { _isLoading: { state: true } }`. Changes to these properties automatically trigger re-renders of only the affected parts.\n\n#### Shared Style System\nThe [`shared-styles.js`](https://github.com/Lissy93/framework-benchmarks/blob/main/apps/lit/src/shared-styles.js) demonstrates Lit's CSS module system using `css` tagged template literals for design system consistency across components.\n\n#### Shadow DOM Encapsulation\nEach Lit component renders in its own Shadow DOM, providing true style encapsulation without CSS-in-JS runtime overhead.",
      "about": "Lit is a framework from Google built around Web Components. \nIt’s minimal, modern and uses standard browser APIs rather than reinventing the wheel. \nGreat when you want reusable components without a massive framework overhead. \nIt’s gaining traction for design systems and apps that need native-feeling components.",
      "thoughts": "Lit can feel like stepping back into the old React class component days, but actually the cohesion to web standards makes Lit pretty... lit. It's built around Web Components, which is both its greatest strength and biggest frustration. Everything is properly encapsulated and framework-agnostic, but the developer experience feels surprisingly verbose for 2025.\n\nThe weird expression syntax has caught me out a lot. Want to bind a property? Use `.value=\"${this.temp}\"`. A boolean attribute? `?disabled=\"${this.loading}\"`. An event listener? `@click=\"${this.handleClick}\"`. It's functional once you memorize the symbols, but it breaks the flow when you're trying to think about business logic.\n\nClass-based components can feel outdated after years of hooks and functional patterns. Creating a simple weather display requires extending `LitElement`, defining `@property` decorators, implementing `render()`, and handling lifecycle methods manually. It works, but feels like unnecessary ceremony.\n\nThe shadow DOM isolation is cool in theory - your styles can't leak, global CSS can't interfere. But in practice, it creates more problems than it solves. Want to style components consistently? Good luck getting your design system to work across shadow boundaries. Because of this, I really struggled to get the shared weather styles working across the Lit app. If you want to submit a PR to fix this, please do!\n\nBut Lit really does shine for design systems and component libraries where you need true framework-agnostic components. I did build [Email Comparison](https://email-comparison.as93.net/) in Lit, but in heindsite, I think that was a mistake!"
    },
    {
      "id": "vanjs",
      "name": "VanJS",
      "implementation": "#### Hyperscript DOM Creation\nThe [`main.js`](https://github.com/Lissy93/framework-benchmarks/blob/main/apps/vanjs/src/main.js) uses VanJS's hyperscript syntax with `const { div, h1, p } = van.tags` to create DOM elements functionally without JSX or templates.\n\n#### Reactive State with van.state\nVanJS provides reactive state through `van.state('initial')` which returns an object with a `.val` property. Changes to `state.val` automatically trigger re-renders of dependent DOM.\n\n#### Functional Component Pattern\nComponents are plain JavaScript functions that return DOM elements. The `WeatherApp` class demonstrates organizing complex UI logic while maintaining VanJS's functional approach.\n\n#### Direct DOM Manipulation\nUnlike virtual DOM frameworks, VanJS directly manipulates the real DOM, making it extremely lightweight (~1KB) while maintaining reactivity through state bindings.\n\n#### Template-less Architecture\nNo templates, JSX, or HTML strings - everything is created through JavaScript functions, providing full IDE support and type safety for DOM creation.",
      "about": "VanJS is an ultra-tiny library for writing reactive UIs with plain functions. \nNo build step, no virtual DOM, just direct DOM manipulation with reactivity built in. \nIt’s surprisingly powerful for its size and is good for small apps or embedded widgets. \nThink of it as a modern alternative to jQuery that actually plays nice with modern JS.",
      "thoughts": "VanJS is impressively tiny - just 1KB of runtime with zero dependencies. It's basically \"what if we took the reactive parts of modern frameworks and stripped away everything else?\" The result is surprisingly elegant for simple applications, but you'll quickly bump into its limitations.\n\nThe functional approach is refreshing after dealing with classes and complex component lifecycles. `van.state(initialValue)` creates reactive state, `van.tags.div()` creates DOM elements, and everything just works. Our weather app's temperature display is literally `van.tags.span(temperature)` - when `temperature` changes, the DOM updates automatically.\n\nBut the simplicity comes with trade-offs. There's no component abstraction beyond functions, no templating system, no event system. You're essentially building a reactive version of vanilla DOM manipulation. It works for basic interactivity but gets unwieldy fast.\n\nThe DOM creation syntax is functional but verbose: `van.tags.div({class: \"weather-card\"}, van.tags.h2(\"Weather\"))`. Coming from JSX or template languages, it feels like writing assembly code. You'll miss the declarative nature of modern frameworks.\n\nVanJS works well for simple enhancements where you need just a touch of reactivity without the framework overhead. I've used it for mini apps, like [raid-calculator](https://github.com/lissy93/raid-calculator). But for anything substantial, you'll spend more time fighting the limitations than building features. It's an interesting experiment in minimalism, but modern frameworks exist for good reasons."
    },
    {
      "id": "vanilla",
      "name": "Vanilla JS",
      "implementation": "#### ES6 Class Architecture\nThe [`weather-app.js`](https://github.com/Lissy93/framework-benchmarks/blob/main/apps/vanilla/js/weather-app.js) uses ES6 classes to organize functionality, demonstrating how to structure vanilla JavaScript apps without frameworks.\n\n#### Native DOM APIs\nDirect use of `document.querySelector()`, `createElement()`, `addEventListener()` and other native browser APIs. No abstractions - just the platform as designed by browser vendors.\n\n#### Event-Driven Architecture\nManual event handling with `addEventListener()` and custom event patterns. The app manages its own event lifecycle without framework helpers.\n\n#### Explicit State Management\nState is manually managed through object properties and explicit DOM updates. When data changes, you must manually call update methods to reflect changes in the UI.\n\n#### Modern JavaScript Features\nLeverages async/await, destructuring, template literals, and other ES6+ features to write clean vanilla JavaScript without sacrificing readability.",
      "about": "Vanilla JS just means plain JavaScript, using modern ES6+ features like classes, modules, promises and async/await. \nMost things frameworks used to solve can now be done natively. \nIt’s often the best choice for small projects where adding a framework is overkill. \nPlus, it ensures you really understand the language itself.",
      "thoughts": "Sometimes the best framework is no framework. Vanilla JavaScript forces you to understand what's actually happening under the hood of all those fancy abstractions. No magic, no build steps, no dependency hell - just the web platform as intended.\n\nFor our weather app, vanilla JS is surprisingly capable. `fetch()` handles API calls, `document.querySelector()` finds elements, and `addEventListener()` manages interactions. Modern browser APIs like `localStorage`, `geolocation`, and CSS custom properties give you most of what you need without any external dependencies.\n\nThe challenge is organization and state management. Without a framework's structure, you're responsible for everything - keeping the DOM in sync with data, organizing code sensibly, and avoiding spaghetti. Our weather app uses a simple pub/sub pattern and functional organization, but it requires discipline.\n\nThe performance is excellent since there's no framework overhead, and the bundle size is minimal. Everything loads fast, and you're not shipping someone else's code to your users. For simple applications or when performance is critical, vanilla JS can be the right choice.\n\nBut you'll miss the conveniences of modern frameworks - automatic updates, component organization, and developer experience. What takes one line in React might take ten in vanilla JS. It's a trade-off between control and convenience."
    }
  ]
}